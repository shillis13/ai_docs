# Federated AI Memory Architecture (Condensed)
# Full source: federated_memory_architecture.md

metadata:
  scope: "distributed AI memory federation"
  principle: "write immediately; curate later; never checkpoint"
  control: "user sets structure/pointers; AIs own content/files"

model:
  nature: "autonomous per-AI persistent memory; shared federation for cross-reference"
  write_path: "slots point to files; AI writes via Desktop Commander without per-write approval"
  rule: "never write to another AI's space"

federation:
  registry: "ai_general/memories/ai_ecosystem_manifest.yml"
  participants:
    desktop_claude:
      manifest: "ai_claude/memories/manifest.yml"
      slots: "03-30 (01-02 reserved for ecosystem/self manifests)"
      cli_agents:
        librarian: {manifest: "ai_claude/memories/cli/librarian/manifest.yml", slots: "01-10"}
        dev_lead: {manifest: "ai_claude/memories/cli/dev-lead/manifest.yml", slots: "01-10"}
        custodian: {manifest: "ai_claude/memories/cli/custodian/manifest.yml", slots: "01-10"}
        ops: {manifest: "ai_claude/memories/cli/ops/manifest.yml", slots: "01-10"}
    codex_mcp: {manifest: "ai_codex/memories/manifest.yml", slots: "01-10"}
    chatgpt: {status: "future/planned"}

ownership:
  ecosystem_manifest_location: user
  individual_manifests: ai_structure
  slot_contents: ai_content
  cross_reference: ai_read_only

slots:
  desktop_claude: {range: "03-30", reserve: "01-02 for manifests"}
  cli_agents: {range: "01-10 each"}
  codex: {range: "01-10"}

logging:
  pattern:
    wrong: "batch insights then save later"
    right: {append: "immediate to slot", fields: ["ts", "content"]}
  scope:
    desktop_claude: "user prefs, tool patterns, project context"
    librarian: "query patterns, corpus locations, search shortcuts"
    dev_lead: "task patterns, code insights, architecture decisions"
    custodian: "structure patterns, naming exceptions, archive decisions"
    ops: "execution patterns, timing insights, error recovery"
    codex: "implementation patterns, code generation learnings"

manifest_format:
  metadata_fields: [owner, type, version, created, philosophy]
  slots: "mapping slot-> {purpose, file}; AI assigns as needs emerge"
  usage:
    logging: "append timestamped observations as they occur"
    format: "YAML list entries with ts/content"
    curation: "periodic review to promote, archive, or merge"

slot_files:
  structure: "entries: list of {ts, content}"
  note: "append-friendly per slot"

read_tracking_future:
  field: "reads: increment per access (optional)"
  curation_rules:
    - "high reads -> promote to condensed summary"
    - "zero reads after 30 days -> archive candidate"
    - "often read together -> cluster/merge"

cli_persistence:
  method: "named sessions preserve continuity"
  resume_cmd: "claude_cli.sh -n <agent> \"...\""
  registry: "~/.claude/session_registry.yml"

cross_reference:
  read: "manifests/slots from others always readable"
  write_block: "never write to other AI spaces"
  wrong_example: "write_file(ai_codex/memories/mem_slots/01.yml, ...)"
  right_path: "ai_general/coordination/messages/to_codex.yml"

integration:
  desktop_claude_boot:
    - "load ecosystem manifest (slot 1 pointer)"
    - "load own manifest (slot 2 pointer)"
    - "load active slots per manifest"
    - "inspect other manifests for cross-reference"
  cli_agent_boot:
    - "agents.json supplies memory instructions"
    - "resume named session for continuity"
    - "read own manifest for slot purposes"
    - "begin logging immediately"
  codex_tasks:
    - "receive task with memory hints"
    - "read relevant slots if needed"
    - "log implementation learnings to own slots"
    - "return results without memory overhead in response"

related_docs:
  - "instr_memory_slot_protocol_v2.yml"
  - "ai_ecosystem_manifest.yml"
  - "~/.claude/agents.json"
