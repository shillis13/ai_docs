---
metadata:
  title: "AI Scripts & Orchestration Architecture"
  version: "1.2.0"
  date: "2025-11-20"
  status: "active"
  supersedes: "archive/ARCHITECTURE_v1.1.md"
  authors: ["Claude CLI", "Codex CLI", "Desktop Claude"]
  description: "Unified orchestration system for multi-AI coordination, task management, and automated workflows"

#########################################################
# OVERVIEW
#########################################################

overview:
  system_goals:
    - "Enable autonomous multi-AI coordination without user intervention"
    - "Provide clean, composable interfaces for AI communication"
    - "Support synchronous (Layer 1), polling (Layer 2), and async (Layer 3) patterns"
    - "Normalize script organization under unified directory structure"
    - "Facilitate monitoring, scheduling, and notification across all AI channels"
  
  design_principles:
    - "Flat-plus-internal layout: Main entry points at top level, channel-specific in _internal/"
    - "Router pattern: Entry scripts validate and route to channel implementations"
    - "Non-blocking operations: Notifications never block prompt delivery"
    - "File-based coordination: Simple, debuggable, survives process crashes"
    - "Session-aware: Track and target specific terminal/browser sessions"
    - "Fail-safe defaults: Degrade gracefully when channels unavailable"
  
  major_components:
    - "Core Entry Points (ai_isBusy, send_prompt, send_notification, monitor)"
    - "Scheduling System (time-based prompt delivery)"
    - "Coordination System (task assignment and execution)"
    - "Terminal Session Tracking (iTerm2 session mapping)"
    - "Notification Pipeline (async alerts and status updates)"
    - "Pulse System (legacy monitoring, migration path defined)"
  
  evolution_from_v1_1:
    - "Added send_notification.sh system (4 channels: desktop, webui, cli, user)"
    - "Added scheduling triple (set_scheduled_prompt, send_scheduled_prompt, daemon)"
    - "Unified monitor.sh with pattern matching and output modes"
    - "Standardized _internal/ structure across all entry points"
    - "Defined migration strategy from pulse/ to new monitor+notification"
    - "Enhanced coordination system with scheduling/ and notifications/ directories"

#########################################################
# DIRECTORY STRUCTURE
#########################################################

directory_structure:
  base_path: "~/Documents/AI/ai_root/ai_general/scripts"
  layout_type: "flat-plus-internal"
  description: "Main entry points at scripts/ root, channel-specific implementations in _internal/"
  
  structure:
    scripts_root:
      path: "scripts/"
      contents:
        - "ai_isBusy.sh          # Check if AI can accept prompts"
        - "send_prompt.sh        # Send prompts to AI instances"
        - "send_notification.sh  # Non-blocking notifications"
        - "monitor.sh            # Read content from AI interfaces"
        - "set_scheduled_prompt.sh     # Create/manage schedules"
        - "send_scheduled_prompt.sh    # Execute scheduled prompts"
        - "scheduled_prompts_daemon.sh # Background scheduler"
        - "new_iterm_tab.sh      # Create new iTerm2 tabs"
        - "cli_browser_automation_example.sh  # Browser automation template"
      
    internal_implementations:
      path: "scripts/_internal/"
      description: "Channel-specific implementations called by entry points"
      contents:
        ai_isBusy:
          - "_ai_isBusy_desktop.sh   # Claude Desktop busy check"
          - "_ai_isBusy_cli.sh        # CLI session busy check"
          - "_ai_isBusy_webui.sh      # Browser AI busy check"
        
        monitor:
          - "_monitor_desktop.sh      # Read from Claude Desktop"
          - "_monitor_cli.sh          # Read from CLI sessions"
          - "_monitor_webui.sh        # Read from browser AIs"
        
        send_notification:
          - "_send_notification_desktop.sh  # Notify Claude Desktop"
          - "_send_notification_cli.sh      # Notify CLI sessions"
          - "_send_notification_webui.sh    # Notify browser AIs"
          - "_send_notification_user.sh     # macOS user notifications"
    
    cli_utilities:
      path: "scripts/cli/"
      subdirs:
        lifecycle: "cleanup_cli_sessions.sh, list_cli_sessions.sh"
        wrappers: "cli_script_wrapper.sh, cli_tmux_wrapper.sh, check_lock.sh"
    
    notifications:
      path: "scripts/notifications/"
      subdirs:
        desktop: "notify_desktop_smart.sh, notify_desktop_task_complete.sh"
        pipeline: "write_notification.sh, process_notifications.sh, process_notifications_cron.sh"
    
    pulse_system:
      path: "scripts/pulse/"
      status: "legacy - migration in progress"
      subdirs:
        core: "pulse_claude.sh, pulsing_daemon.sh, start_pulse.sh, stop_pulse.sh"
        monitoring: "check_pulse_system.sh, pulse_status.sh, test_cli_monitoring.sh"
        prompts: "check_completions.sh, inject_cli_command.sh"
      migration_note: "See migration section for pulse/ → monitor.sh + send_notification.sh path"
    
    orchestration:
      path: "scripts/orchestration/"
      description: "Higher-level coordination helpers"
    
    legacy:
      path: "scripts/legacy/"
      description: "Deprecated scripts kept for reference"
      subdirs:
        to_migrate: "Scripts pending migration review"
    
    tests:
      path: "scripts/tests/"
      contents:
        - "test_notification_system.sh"
        - "test_send_notification_channels.sh"
    
    install:
      path: "scripts/install/"
      contents:
        - "install_cron_jobs.sh"
    
    setup:
      path: "scripts/setup/"
      contents:
        - "rebuild_myenv.sh"
        - "setup_ai_chatgpt_repo.sh"
        - "setup_ai_claude_repo.sh"

#########################################################
# CORE ENTRY POINTS
#########################################################

entry_points:
  
  ai_isBusy:
    script: "ai_isBusy.sh"
    signature: "ai_isBusy.sh {AI_TYPE} {CONVO_ID}"
    purpose: "Check if AI instance can accept prompts (non-blocking readiness check)"
    status: "implemented"
    
    parameters:
      AI_TYPE:
        type: "string"
        values: ["desktop", "cli", "webui"]
        description: "Target AI channel type"
      CONVO_ID:
        type: "string"
        description: "Conversation/session identifier"
    
    exit_codes:
      0: "Idle (safe to send)"
      1: "Busy (wait or fallback)"
      2: "Unknown state / error"
    
    internals:
      - script: "_ai_isBusy_desktop.sh"
        purpose: "Check Claude Desktop app state via AppleScript"
      - script: "_ai_isBusy_cli.sh"
        purpose: "Check CLI session state via iTerm2 session tracking"
      - script: "_ai_isBusy_webui.sh"
        purpose: "Check browser AI state via Puppeteer/CDP"
    
    examples:
      - "ai_isBusy.sh desktop 12345"
      - "ai_isBusy.sh cli 67890"
      - "ai_isBusy.sh webui chatgpt"
  
  send_prompt:
    script: "send_prompt.sh"
    signature: "send_prompt.sh {TARGET} {MESSAGE}"
    purpose: "Queue prompts for delivery to AI instances"
    status: "implemented"
    
    parameters:
      TARGET:
        type: "string"
        values: ["claude-desktop", "claude-web", "claude-cli", "codex-cli", "chatgpt-app", "chatgpt-web", "user"]
        description: "Target AI or user channel"
      MESSAGE:
        type: "string"
        description: "Prompt text to deliver"
    
    queue_mapping:
      claude-desktop: "~/Documents/AI/ai_root/ai_comms/claude/prompting/incoming/scheduled/"
      claude-web: "~/Documents/AI/ai_root/ai_comms/claude/prompting/incoming/scheduled/"
      claude-cli: "~/.claude/coordination/to_execute/"
      codex-cli: "~/Documents/AI/ai_root/ai_comms/codex_cli/to_execute/"
      chatgpt: "~/Documents/AI/ai_root/ai_comms/chatgpt/inbox/"
      user: "~/Documents/AI/ai_root/ai_comms/claude/notifications/pending/"
    
    features:
      - "File-based queueing for reliability"
      - "Timestamped filenames for ordering"
      - "Target-specific queue directories"
      - "Fallback options (--fb_queue, --fb_notification)"
    
    examples:
      - 'send_prompt.sh claude-desktop "Check coordination inbox"'
      - 'send_prompt.sh chatgpt-web "Analyze this data"'
  
  send_notification:
    script: "send_notification.sh"
    signature: "send_notification.sh {TARGET} {TARGET_ID} {MESSAGE} [OPTIONS]"
    purpose: "Non-blocking notifications to AIs and user (async status updates)"
    status: "implemented"
    implementation_task: "req_2123"
    
    parameters:
      TARGET:
        type: "string"
        values: ["desktop", "webui", "cli", "user"]
        description: "Notification channel"
      TARGET_ID:
        type: "string"
        description: "Specific instance identifier (session ID, window ID, etc)"
      MESSAGE:
        type: "string"
        description: "Notification text"
    
    options:
      priority:
        flag: "--priority {low|normal|high|urgent}"
        default: "normal"
        description: "Notification priority level"
      persist:
        flag: "--persist"
        description: "Keep in queue until acknowledged"
      sound:
        flag: "--sound"
        description: "Play alert sound / terminal bell"
    
    environment:
      SEND_NOTIFICATION_DRY_RUN:
        description: "Set to 1 to skip external side-effects (testing mode)"
    
    internals:
      - script: "_send_notification_desktop.sh"
        purpose: "Notify Claude Desktop via coordination system + AppleScript"
        method: "Write to notifications/pending/, optionally inject prompt"
      
      - script: "_send_notification_cli.sh"
        purpose: "Notify CLI instances via iTerm2 session"
        method: "Write to session-specific notification queue, optional terminal bell"
      
      - script: "_send_notification_webui.sh"
        purpose: "Notify browser AIs via coordination queue"
        method: "Write to webui-specific notification directory"
      
      - script: "_send_notification_user.sh"
        purpose: "macOS user notifications"
        method: "osascript display notification, system alert sounds"
    
    logging:
      log_file: "scripts/logs/send_notification.log"
      format: "[timestamp] target={target} id={target_id} priority={priority} persist={persist} sound={sound}"
    
    examples:
      - 'send_notification.sh desktop 48B10940 "Task req_2123 complete" --priority high --sound'
      - 'send_notification.sh cli $ITERM_SESSION_ID "Build finished" --priority normal'
      - 'send_notification.sh user desktop "Error detected in log" --priority urgent'
  
  monitor:
    script: "monitor.sh"
    signature: "monitor.sh {TARGET_TYPE} {TARGET_ID} [OPTIONS]"
    purpose: "Read content from AI interfaces (CLI, Desktop, WebUI)"
    status: "in_progress"
    implementation_task: "req_1005"
    
    parameters:
      TARGET_TYPE:
        type: "string"
        values: ["cli", "desktop", "webui"]
        description: "Interface type to monitor"
      TARGET_ID:
        type: "string"
        description: "Specific instance identifier"
    
    options:
      pattern:
        flag: "--pattern REGEX"
        description: "Filter output by regex pattern"
      output:
        flag: "--output MODE"
        values: ["cleaned", "raw"]
        default: "cleaned"
        description: "Output processing mode"
      lines:
        flag: "--lines N"
        default: 50
        description: "Number of lines to return"
    
    internals:
      - script: "_monitor_cli.sh"
        purpose: "Read from CLI terminal sessions"
        method: "iTerm2 session capture, terminal scrollback parsing"
      
      - script: "_monitor_desktop.sh"
        purpose: "Read from Claude Desktop"
        method: "AppleScript UI element extraction, accessibility API"
      
      - script: "_monitor_webui.sh"
        purpose: "Read from browser AI interfaces"
        method: "Puppeteer DOM extraction, CDP protocol"
    
    use_cases:
      - "Detect task completion markers"
      - "Watch for error patterns"
      - "Extract AI responses for processing"
      - "Monitor long-running operations"
    
    examples:
      - "monitor.sh cli session_12345"
      - 'monitor.sh desktop claude --pattern "COMPLETE:"'
      - "monitor.sh webui chatgpt --output raw --lines 100"
  
  scheduling_system:
    scripts:
      - name: "set_scheduled_prompt.sh"
        signature: "set_scheduled_prompt.sh {create|update|cancel|list} [ARGS]"
        purpose: "Create and manage scheduled prompts"
      
      - name: "send_scheduled_prompt.sh"
        signature: "send_scheduled_prompt.sh {SCHEDULE_FILE}"
        purpose: "Execute a scheduled prompt (called by daemon)"
      
      - name: "scheduled_prompts_daemon.sh"
        signature: "scheduled_prompts_daemon.sh {start|stop|status|reload|process}"
        purpose: "Background daemon to process scheduled prompts"
    
    status: "implemented"
    implementation_task: "req_2124"
    
    schedule_directory: "~/.claude/coordination/scheduling/"
    subdirectories:
      active: "Active schedules awaiting execution"
      completed: "One-time schedules that have run"
      cancelled: "User-cancelled schedules"
    
    schedule_types:
      once:
        description: "Execute once at specified time"
        examples: ["+30m", "+2h", "2025-11-20 14:00:00"]
      periodic:
        description: "Repeat on interval"
        examples: ["@hourly", "@daily", "*/5 (every 5 minutes)", "*/30 (every 30 minutes)"]
    
    schedule_file_format:
      required_fields:
        - "schedule_id: Unique identifier"
        - "target: AI target (desktop, cli, webui)"
        - "target_id: Specific instance"
        - "prompt: Message to send"
        - "schedule_spec: When to execute"
        - "schedule_type: once or periodic"
        - "next_run: Next execution timestamp"
        - "priority: low|normal|high|urgent"
        - "status: pending|active|completed|cancelled"
        - "created: Creation timestamp"
        - "updated: Last update timestamp"
    
    daemon_operation:
      scan_interval: "60 seconds (configurable)"
      lock_mechanism: "flock on daemon.lock prevents concurrent processing"
      pid_tracking: "daemon.pid contains running daemon PID"
      logging: "~/.claude/coordination/logs/scheduling.log"
    
    integration:
      - "Calls send_prompt.sh for prompt delivery"
      - "Uses --fb_queue and --fb_notification for fallbacks"
      - "Periodic schedules update next_run and remain in active/"
      - "One-time schedules move to completed/ after execution"
    
    examples:
      - 'set_scheduled_prompt.sh create check_inbox desktop 48B10940 "check inbox" "+30m" normal'
      - 'set_scheduled_prompt.sh create daily_summary desktop 48B10940 "summarize today" "@daily" normal'
      - "set_scheduled_prompt.sh list"
      - "scheduled_prompts_daemon.sh start"

#########################################################
# INTEGRATION PATTERNS
#########################################################

integration_patterns:
  
  coordination_system:
    base_path: "~/.claude/coordination/"
    description: "File-based task coordination between Desktop Claude and CLI instances"
    
    structure:
      tasks:
        incoming: "New task assignments from Desktop Claude"
        in_progress: "Tasks currently being worked on by CLI instances"
        completed: "Finished tasks with responses"
      
      broadcasts:
        description: "System-wide announcements visible to all CLI instances"
        format: "Markdown files with broadcast metadata"
      
      scheduling:
        active: "Scheduled prompts awaiting execution"
        completed: "Executed one-time schedules"
        cancelled: "User-cancelled schedules"
      
      notifications:
        pending: "New notifications awaiting delivery"
        processed: "Delivered notifications (archived)"
      
      logs:
        description: "System operation logs (scheduling.log, etc)"
    
    workflows:
      task_assignment:
        - "Desktop Claude posts task to tasks/incoming/req_XXXX_description.md"
        - "CLI instance claims by moving to tasks/in_progress/req_XXXX/"
        - "CLI executes task, writes response_001_cli_PID.md"
        - "CLI moves task folder to tasks/completed/"
        - "CLI calls send_notification.sh to alert Desktop Claude"
      
      broadcast_message:
        - "Desktop Claude writes to broadcasts/YYYYMMDD_topic.md"
        - "All CLI instances check broadcasts/ on startup"
        - "CLIs process relevant broadcasts and optionally respond"
      
      multi_step_task:
        - "Desktop posts initial task to tasks/in_progress/req_XXXX/"
        - "CLI completes step 1, writes response_001"
        - "Desktop adds followup_001.md with next instructions"
        - "CLI processes followup, writes response_002"
        - "Continues until Desktop marks complete or CLI finishes"
  
  terminal_session_tracking:
    environment_variables:
      ITERM_SESSION_ID:
        description: "Unique iTerm2 session identifier"
        format: "w{window_id}t{tab_id}p{pane_id}"
        propagation: "Set by iTerm2, inherited by subprocesses"
      
      TERM_SESSION_ID:
        description: "macOS Terminal.app session identifier"
        propagation: "Set by Terminal.app"
      
      CLI_INSTANCE_ID:
        description: "PID of CLI instance ($$)"
        usage: "Liveness marker: ~/.claude/.cli_instance_$$"
    
    wrappers:
      codex.sh:
        description: "Wrapper for Codex CLI"
        ensures: "ITERM_SESSION_ID propagated to CLI process"
      
      claude.sh:
        description: "Wrapper for Claude CLI"
        ensures: "ITERM_SESSION_ID propagated to CLI process"
    
    purpose:
      - "Route notifications to correct terminal session"
      - "Target specific CLI instances for prompts"
      - "Track active CLI sessions for monitoring"
      - "Enable CLI-to-CLI direct communication"
    
    registry:
      location: "~/.claude/cli_sessions/ (conceptual, not yet implemented)"
      contents: "Mapping of CLI_INSTANCE_ID → ITERM_SESSION_ID, start time, status"
  
  notification_flows:
    
    desktop_to_cli:
      trigger: "Task posted to coordination system"
      flow:
        - "Desktop Claude writes task to tasks/incoming/"
        - "Desktop calls send_notification.sh cli {session_id} 'New task req_XXXX'"
        - "_send_notification_cli.sh writes to CLI-specific queue"
        - "CLI checks queue periodically or on notification receipt"
        - "CLI claims and executes task"
      
      alternatives:
        - "Direct prompt injection via iTerm2 API (Layer 2)"
        - "User manually prompts CLI to check inbox"
    
    cli_to_desktop:
      trigger: "CLI completes task"
      flow:
        - "CLI writes response to tasks/completed/req_XXXX/"
        - "CLI calls send_notification.sh desktop {desktop_id} 'Task req_XXXX complete'"
        - "_send_notification_desktop.sh writes to notifications/pending/"
        - "Desktop Claude checks pending/ (periodic or on-demand)"
        - "Desktop reviews response and takes action"
      
      alternatives:
        - "CLI uses send_prompt.sh for urgent notifications"
        - "Scheduled daemon prompts Desktop to check completed/"
    
    cli_to_user:
      trigger: "Error detected, critical alert needed"
      flow:
        - "CLI detects error condition"
        - 'CLI calls send_notification.sh user desktop "Error in req_XXXX" --priority urgent --sound'
        - "_send_notification_user.sh triggers macOS notification"
        - "User sees system notification banner"
        - "User investigates via Desktop Claude or CLI session"
    
    periodic_checks:
      trigger: "Scheduled monitoring"
      flow:
        - "scheduled_prompts_daemon.sh running in background"
        - "Daemon checks active schedules every 60 seconds"
        - "When schedule due, calls send_scheduled_prompt.sh"
        - "Prompt delivered via send_prompt.sh"
        - "Target AI receives prompt and processes"
      
      examples:
        - "Every 30 minutes: Check coordination inbox for new tasks"
        - "Daily at 9am: Summarize yesterdays completed tasks"
        - "Hourly: Monitor system health and report anomalies"
  
  monitoring_patterns:
    
    pattern_watching:
      description: "Monitor AI interface for specific patterns, trigger actions"
      implementation:
        - "Call monitor.sh cli {session_id} --pattern 'COMPLETE:' --output cleaned"
        - "Parse output for completion markers"
        - "When detected, send notification or execute followup task"
      
      use_cases:
        - "Detect task completion without polling coordination system"
        - "Watch for error messages in AI output"
        - "Trigger actions based on AI state changes"
    
    completion_detection:
      description: "Watch for task completion markers in AI output"
      pattern: "COMPLETE: {task_id}"
      flow:
        - "CLI or monitor script watches AI output"
        - "Detects 'COMPLETE: req_XXXX' marker"
        - "Triggers send_notification.sh to alert orchestrator"
        - "Orchestrator reviews completed task"
    
    error_detection:
      description: "Watch for error patterns, alert user immediately"
      patterns:
        - "ERROR:"
        - "FAILED:"
        - "Exception:"
        - "Traceback:"
      flow:
        - "monitor.sh cli {session} --pattern 'ERROR:'"
        - "If match found, call send_notification.sh user desktop ..."
        - "User notified of error for intervention"
    
    state_monitoring:
      description: "Periodic checks of AI state (busy/idle)"
      flow:
        - "Scheduled check calls ai_isBusy.sh {target} {id}"
        - "Exit code indicates state"
        - "If busy for extended period, send alert"
        - "Prevents queue buildup and missed prompts"

#########################################################
# SYSTEM BOUNDARIES & INTERFACES
#########################################################

system_boundaries:
  
  desktop_claude_capabilities:
    can_do:
      - "Read/write files via filesystem"
      - "Execute bash commands"
      - "Call AppleScript via osascript"
      - "Read coordination directories"
      - "Write task definitions"
      - "Process task responses"
      - "Send notifications via send_notification.sh"
    
    cannot_do:
      - "Directly access iTerm2 Python API (runs in different process)"
      - "Type into other application windows (limited AppleScript access)"
      - "Control browser automation (no Puppeteer access)"
      - "Read terminal scrollback directly"
    
    workarounds:
      - "Use CLI instances as agents for terminal operations"
      - "Use browser automation scripts for web AI access"
      - "Coordinate via file-based task system"
  
  cli_instance_capabilities:
    can_do:
      - "Full terminal access (read scrollback, execute commands)"
      - "Access iTerm2 session information via environment variables"
      - "Execute Python scripts with iTerm2 API"
      - "Run browser automation (Puppeteer, Playwright)"
      - "Read/write coordination files"
      - "Claim and execute tasks"
      - "Send notifications to all channels"
      - "Monitor other AI interfaces"
    
    cannot_do:
      - "Directly access Claude Desktop UI (AppleScript limitations)"
      - "Persist across terminal session closure (ephemeral)"
      - "Guarantee execution order across multiple instances"
    
    workarounds:
      - "Use send_notification.sh desktop for Desktop Claude communication"
      - "Use liveness markers (CLI_INSTANCE_ID files) for session tracking"
      - "Use coordination locks for mutual exclusion"
  
  browser_automation:
    capabilities:
      - "Puppeteer: Full browser control, DOM access, event triggering"
      - "CDP (Chrome DevTools Protocol): Low-level browser inspection"
      - "Read AI responses from web interfaces"
      - "Type prompts into web chat interfaces"
      - "Monitor browser-based AI state"
    
    limitations:
      - "Requires browser in debug mode (--remote-debugging-port=9222)"
      - "Anti-automation detection by some sites"
      - "Session timeouts and login requirements"
      - "Slower than native APIs"
    
    supported_targets:
      - "Claude Web (claude.ai)"
      - "ChatGPT Web (chat.openai.com)"
      - "Gemini Web (gemini.google.com)"
      - "Grok Web (grok.x.ai)"
  
  applescript_capabilities:
    can_do:
      - "Control macOS apps with AppleScript dictionary support"
      - "Send keystrokes to focused window"
      - "Display user notifications"
      - "Read UI element properties (accessibility API)"
      - "Activate/focus specific applications"
    
    limitations:
      - "Limited access to Claude Desktop internals"
      - "Fragile (breaks with UI changes)"
      - "Slow compared to native APIs"
      - "Requires app to be frontmost for many operations"
    
    use_cases:
      - "Notify Desktop Claude via display notification"
      - "Focus Claude Desktop window"
      - "Trigger cron-based prompt injection (legacy pulse system)"

#########################################################
# MIGRATION STRATEGY
#########################################################

migration:
  
  overview:
    from: "pulse/ monitoring system"
    to: "monitor.sh + send_notification.sh + scheduled_prompts_daemon.sh"
    reason: "Unified interfaces, better channel separation, more maintainable"
  
  pulse_components:
    
    keep:
      - script: "pulse/core/pulse_claude.sh"
        reason: "Low-level terminal monitoring, specific to pulsing pattern"
        action: "Keep as specialized tool for terminal state reading"
      
      - script: "pulse/core/pulsing_daemon.sh"
        reason: "Working cron-based pulse delivery system"
        action: "Continue using until scheduled_prompts_daemon.sh is stable"
    
    migrate:
      - component: "pulse/monitoring/*.sh → _internal/_monitor_cli.sh patterns"
        scripts: ["check_pulse_system.sh", "pulse_status.sh", "test_cli_monitoring.sh"]
        action: "Extract pattern matching and state detection logic"
        target: "_monitor_cli.sh and monitor.sh --pattern option"
      
      - component: "pulse/prompts/*.sh → send_notification.sh patterns"
        scripts: ["check_completions.sh", "inject_cli_command.sh"]
        action: "Reimplement as notification flows using send_notification.sh"
        target: "_send_notification_cli.sh for direct injection"
      
      - component: "pulse/core/pulsing_daemon.sh → scheduled_prompts_daemon.sh"
        action: "Migrate cron-based periodic checks to scheduling system"
        target: "scheduled_prompts_daemon.sh with @hourly/@daily schedules"
    
    deprecate:
      - component: "pulse/prompts/send_scheduled_prompt.sh"
        reason: "Superseded by scripts/send_scheduled_prompt.sh"
        action: "Mark deprecated, update references, eventual removal"
      
      - component: "pulse/fix_cron*.sh, pulse/launchd_control.sh"
        reason: "Scheduling system uses launchd/systemd directly"
        action: "Keep for reference, move to scripts/legacy/"
  
  timeline:
    phase_1:
      name: "Build new systems"
      status: "COMPLETE"
      tasks:
        - "req_2123: Implement send_notification.sh"
        - "req_2124: Implement scheduling system"
        - "req_1005: Complete monitor.sh"
      
      deliverables:
        - "All entry points functional"
        - "_internal implementations for all channels"
        - "Test suite for notification and scheduling"
    
    phase_2:
      name: "Parallel operation"
      status: "CURRENT"
      tasks:
        - "Run pulse/ and new systems side-by-side"
        - "Validate new system reliability"
        - "Compare outputs and behaviors"
        - "Fix any gaps or regressions"
      
      duration: "2-4 weeks"
      success_criteria:
        - "New system handles all pulse/ use cases"
        - "No loss of functionality"
        - "Better or equal performance"
    
    phase_3:
      name: "Migrate workflows"
      status: "PLANNED"
      tasks:
        - "Update cron jobs to use scheduled_prompts_daemon.sh"
        - "Replace pulse/prompts/* calls with send_notification.sh"
        - "Update monitoring scripts to use monitor.sh"
        - "Document migration for any custom pulse/ users"
      
      deliverables:
        - "All automated workflows use new system"
        - "pulse/ scripts no longer called by cron/daemon"
        - "Migration guide published"
    
    phase_4:
      name: "Deprecation"
      status: "FUTURE"
      tasks:
        - "Mark pulse/ as deprecated (add DEPRECATED.md)"
        - "Move pulse/ to scripts/legacy/pulse/"
        - "Remove from PATH and documentation"
        - "Keep for 6 months for emergency rollback"
      
      deliverables:
        - "scripts/legacy/pulse/ with deprecation notice"
        - "Documentation updated to reference new system only"
        - "DEPRECATED.md explaining migration path"
  
  decision_criteria:
    proceed_to_phase_3_when:
      - "scheduled_prompts_daemon.sh runs for 2 weeks without crashes"
      - "send_notification.sh delivers 100+ notifications successfully"
      - "monitor.sh pattern matching proven reliable"
      - "No critical bugs in new system"
      - "User confirms new system meets needs"
    
    rollback_to_pulse_if:
      - "Critical failures in new system"
      - "Data loss or corruption"
      - "Unacceptable performance degradation"
      - "Missing functionality that cannot be quickly added"

#########################################################
# DESIGN DECISIONS & RATIONALE
#########################################################

design_decisions:
  
  flat_plus_internal_vs_subdirectories:
    decision: "Use flat-plus-internal layout"
    rationale:
      - "Entry points easy to discover at scripts/ root"
      - "Channel-specific code isolated but not deeply nested"
      - "PATH only needs to include scripts/, not subdirectories"
      - "Minimal cognitive overhead for common operations"
      - "Internal implementations can evolve without changing entry point contracts"
    
    alternative_considered: "Subdirectories (scripts/prompt/, scripts/notification/, scripts/monitoring/)"
    why_rejected:
      - "Requires PATH updates or wrapper scripts"
      - "Harder to remember which directory contains which script"
      - "More nesting for simple operations"
  
  yaml_over_json_for_configs:
    decision: "Use YAML for configuration and architecture docs"
    rationale:
      - "Comments supported (critical for documentation)"
      - "Human-readable and human-editable"
      - "Less punctuation noise than JSON"
      - "Native multi-line string support"
      - "Standard for many infrastructure tools (Kubernetes, Ansible, etc)"
    
    alternative_considered: "JSON"
    why_rejected:
      - "No comment support"
      - "Harder to read for humans"
      - "Verbose for nested structures"
  
  file_based_coordination_over_ipc:
    decision: "Use file-based coordination (directories and files)"
    rationale:
      - "Simple and debuggable (just ls and cat)"
      - "Survives process crashes"
      - "No daemon required for basic operation"
      - "Cross-platform (works on any Unix-like system)"
      - "Easy to inspect state manually"
      - "Atomic operations possible with mv"
    
    alternative_considered: "IPC (sockets, message queues, databases)"
    why_rejected:
      - "Requires daemon for coordination"
      - "Harder to debug (can't just cat a socket)"
      - "State lost on process crash unless persisted"
      - "More complex implementation"
    
    tradeoffs:
      - "Slower than in-memory IPC"
      - "No built-in pub/sub (must poll or use fswatch)"
      - "Potential race conditions (mitigated with locks and atomic moves)"
  
  notification_separate_from_prompt:
    decision: "send_notification.sh is separate from send_prompt.sh"
    rationale:
      - "Different semantics: prompts demand response, notifications inform"
      - "Notifications are non-blocking by design"
      - "Different delivery guarantees (best-effort vs guaranteed delivery)"
      - "Separate queues prevent notification spam from blocking prompts"
      - "Allows different retry logic and persistence policies"
    
    alternative_considered: "Unified send_message.sh with --type flag"
    why_rejected:
      - "Mixing concerns makes interface harder to use"
      - "Harder to enforce non-blocking for notifications"
      - "More complex routing logic"
  
  scheduling_daemon_vs_cron:
    decision: "Use scheduled_prompts_daemon.sh with file-based schedules"
    rationale:
      - "Cron limited to fixed intervals, not relative times (+30m)"
      - "Dynamic scheduling (add schedules without editing crontab)"
      - "Schedule files are self-documenting"
      - "Easy to cancel or update schedules without cron knowledge"
      - "Daemon can handle complex scheduling logic"
      - "Better logging and error handling"
    
    alternative_considered: "Pure cron with at for one-time schedules"
    why_rejected:
      - "Cron requires editing crontab (not user-friendly)"
      - "at command not available on all systems"
      - "No easy way to list or update schedules programmatically"
      - "Harder to integrate with coordination system"
    
    hybrid_approach:
      - "Use launchd/systemd to start daemon on boot"
      - "Daemon handles all scheduling logic"
      - "Best of both worlds: reliability of system scheduler + flexibility of file-based schedules"

#########################################################
# TESTING & VALIDATION
#########################################################

testing:
  
  integration_tests:
    
    notification_delivery:
      test_file: "scripts/tests/test_notification_system.sh"
      tests:
        - "send_notification.sh desktop → notifications/pending/"
        - "send_notification.sh cli → iTerm2 session bell"
        - "send_notification.sh user → macOS notification"
        - "send_notification.sh webui → webui queue"
        - "Priority handling (urgent gets delivered first)"
        - "Persist flag keeps notification until acknowledged"
        - "Sound flag triggers terminal bell"
      
      success_criteria:
        - "All channels deliver successfully"
        - "Correct files created in expected locations"
        - "Logs show proper metadata"
        - "No crashes or errors"
    
    scheduling_execution:
      test_file: "scripts/tests/test_scheduling_system.sh"
      tests:
        - "Create schedule with +5m relative time"
        - "Daemon picks up and executes schedule"
        - "Periodic schedule (@hourly) updates next_run"
        - "One-time schedule moves to completed/"
        - "Cancel schedule before execution"
        - "Update schedule after creation"
      
      success_criteria:
        - "Schedules execute within 60 seconds of due time"
        - "Periodic schedules remain active"
        - "One-time schedules complete properly"
        - "Daemon recovers from crashes (restart picks up schedules)"
    
    coordination_flow:
      test_file: "scripts/tests/test_coordination_flow.sh"
      tests:
        - "Desktop posts task to tasks/incoming/"
        - "CLI claims task (moves to in_progress/)"
        - "CLI writes response"
        - "CLI moves to completed/"
        - "CLI sends notification to Desktop"
        - "Desktop receives notification"
      
      success_criteria:
        - "Task folder moves through states correctly"
        - "Response file created with expected format"
        - "Notification delivered to Desktop"
        - "No file corruption or race conditions"
    
    monitoring_patterns:
      test_file: "scripts/tests/test_monitor_patterns.sh"
      tests:
        - "monitor.sh cli {session} returns output"
        - "monitor.sh --pattern 'ERROR' filters correctly"
        - "monitor.sh --output raw preserves formatting"
        - "monitor.sh --lines 10 limits output"
      
      success_criteria:
        - "Output matches expected format"
        - "Pattern filtering works correctly"
        - "Line limits enforced"
        - "No crashes on edge cases (empty output, invalid session)"
  
  test_coverage_expectations:
    entry_points:
      - "100% of entry point scripts have integration tests"
      - "All exit codes documented and tested"
      - "All command-line options tested"
    
    internal_implementations:
      - "Each _internal/*.sh script has unit tests"
      - "Edge cases tested (missing files, invalid IDs, timeouts)"
    
    error_handling:
      - "Graceful degradation tested (channel unavailable)"
      - "Retry logic validated"
      - "Error messages clear and actionable"
  
  validation_checklist:
    new_entry_point:
      - "[ ] Usage documentation in script header"
      - "[ ] Example invocations provided"
      - "[ ] Exit codes documented"
      - "[ ] Integration test written"
      - "[ ] Logged to appropriate log file"
      - "[ ] Error messages to stderr"
      - "[ ] Success messages to stdout"
      - "[ ] Added to this architecture document"
    
    new_internal_implementation:
      - "[ ] Matches entry point interface contract"
      - "[ ] Unit test written"
      - "[ ] Error handling implemented"
      - "[ ] Logging to entry point log file"
      - "[ ] Executable permissions set"
      - "[ ] Shebang and set -euo pipefail"

#########################################################
# FUTURE ENHANCEMENTS
#########################################################

future_enhancements:
  
  multi_ai_coordination:
    description: "Extend coordination system to support Gemini, Grok, ChatGPT"
    requirements:
      - "Unified task format across all AI agents"
      - "AI-specific capabilities registry"
      - "Smart task routing based on AI strengths"
      - "Multi-AI collaboration on single task"
    
    implementation:
      - "Add Gemini, Grok to ai_isBusy.sh and send_prompt.sh targets"
      - "Create _internal implementations for each AI"
      - "Extend coordination system with cross-AI task dependencies"
  
  web_ui_for_monitoring:
    description: "Dashboard for monitoring coordination system state"
    features:
      - "Real-time task status (pending, in progress, completed)"
      - "Active schedule list with next run times"
      - "Notification queue view"
      - "AI instance health status"
      - "Log aggregation and search"
      - "Manual task creation and cancellation"
    
    implementation:
      - "Flask/FastAPI web server reading coordination directories"
      - "WebSocket for real-time updates"
      - "Static HTML/JS frontend"
      - "Authentication for security"
  
  advanced_scheduling:
    description: "Enhanced scheduling capabilities"
    features:
      - "Task dependencies (schedule B after A completes)"
      - "Conditional scheduling (only if condition met)"
      - "Retry policies (retry failed schedules)"
      - "Priority queues (high-priority schedules first)"
      - "Schedule templates (reusable schedule patterns)"
    
    implementation:
      - "Extend schedule file format with dependencies and conditions"
      - "Update daemon to evaluate dependencies before execution"
      - "Add retry logic to send_scheduled_prompt.sh"
  
  comprehensive_logging_observability:
    description: "Unified logging and observability across all systems"
    features:
      - "Structured logging (JSON format)"
      - "Log aggregation (all logs to single location)"
      - "Log levels (DEBUG, INFO, WARN, ERROR)"
      - "Correlation IDs (track request across systems)"
      - "Metrics collection (execution times, success rates)"
      - "Alerting (trigger notifications on error patterns)"
    
    implementation:
      - "Update all scripts to use common logging function"
      - "Centralized log directory with rotation"
      - "Log parsing and analysis tools"
      - "Integration with monitoring systems (Prometheus, Grafana)"
  
  cross_platform_support:
    description: "Support Linux and Windows in addition to macOS"
    requirements:
      - "Abstract platform-specific code (_internal implementations)"
      - "Use cross-platform tools where possible"
      - "Graceful degradation when platform features unavailable"
    
    implementation:
      - "Linux: Use wmctrl/xdotool instead of AppleScript"
      - "Windows: Use PowerShell for automation"
      - "Detect platform at runtime and route accordingly"
  
  plugin_system:
    description: "Allow users to add custom entry points and channels"
    features:
      - "Drop-in plugin directory (scripts/plugins/)"
      - "Plugin manifest (metadata, dependencies, interface)"
      - "Dynamic loading of plugins at runtime"
      - "Plugin marketplace (share plugins with community)"
    
    implementation:
      - "Plugin discovery in scripts/plugins/"
      - "Plugin validation (interface compliance)"
      - "Sandboxing for security"

#########################################################
# VERSION HISTORY
#########################################################

version_history:
  v1_2_0:
    date: "2025-11-20"
    changes:
      - "Added send_notification.sh system (req_2123)"
      - "Added scheduling triple (set_scheduled_prompt, send_scheduled_prompt, daemon) (req_2124)"
      - "Unified monitor.sh with pattern matching and output modes (req_1005)"
      - "Standardized _internal/ structure across all entry points"
      - "Defined migration strategy from pulse/ to new monitor+notification"
      - "Enhanced coordination system with scheduling/ and notifications/ directories"
      - "Created comprehensive architecture_v1.2.yml documentation (req_2125)"
    
    status: "active"
    supersedes: "v1.1"
  
  v1_1_0:
    date: "2025-11-10"
    changes:
      - "Initial unified architecture implementation"
      - "Established flat-plus-internal layout"
      - "Created coordination system (tasks, broadcasts, logs)"
      - "Implemented ai_isBusy.sh and send_prompt.sh"
      - "Terminal session tracking via ITERM_SESSION_ID"
      - "Three-layer communication architecture (sync, polling, async)"
    
    status: "superseded"
    document: "archive/ARCHITECTURE_v1.1.md"

#########################################################
# RELATED DOCUMENTATION
#########################################################

related_documentation:
  current_system:
    - "TODO_MANAGER_STATUS_2025-11-20.md: Current implementation status"
    - "terminal_session_tracking.md: iTerm2 session tracking implementation"
    - "coordination_system_v4_digest.md: CLI coordination protocol"
  
  reference:
    - "ai_communication_architecture_v1.md: Three-layer messaging architecture"
    - "cli_orchestration_v1.md: CLI instance coordination patterns"
    - "daemon_architecture_v1.md: Daemon design patterns"
  
  legacy:
    - "PULSE_SYSTEM_README.md: Original pulse/ monitoring system (to be migrated)"
    - "directory_structure_reference_v02.md: Early directory organization"
  
  tasks:
    - "req_2123: send_notification.sh implementation (completed)"
    - "req_2124: Scheduling system implementation (completed)"
    - "req_1005: monitor.sh implementation (in progress)"
    - "req_2125: This architecture document (in progress)"

#########################################################
# ONBOARDING GUIDE
#########################################################

onboarding:
  for_new_ai_instances:
    start_here:
      - "Read this architecture_v1.2.yml document"
      - "Understand the three core systems: prompting, notification, monitoring"
      - "Review entry point signatures and examples"
      - "Understand coordination system workflow (tasks/incoming → in_progress → completed)"
    
    essential_commands:
      - "ai_isBusy.sh {target} {id} - Check if AI ready"
      - "send_prompt.sh {target} '{message}' - Send prompt"
      - "send_notification.sh {target} {id} '{message}' - Send notification"
      - "monitor.sh {target} {id} - Read AI output"
      - "set_scheduled_prompt.sh list - View scheduled prompts"
    
    coordination_workflow:
      - "Check inbox: ls ~/.claude/coordination/tasks/incoming/"
      - "Claim task: mv incoming/req_XXXX.md in_progress/req_XXXX/"
      - "Execute task commands"
      - "Write response: in_progress/req_XXXX/response_001_cli_$$.md"
      - "Complete: mv in_progress/req_XXXX completed/"
      - "Notify: send_notification.sh desktop {id} 'Task complete'"
    
    common_patterns:
      - "Periodic check: set_scheduled_prompt.sh create check_inbox desktop 48B10940 'check inbox' '@hourly' normal"
      - "One-time reminder: set_scheduled_prompt.sh create reminder desktop 48B10940 'Review results' '+30m' high"
      - "Watch for errors: monitor.sh cli $ITERM_SESSION_ID --pattern 'ERROR:'"
      - "Test notification: send_notification.sh user desktop 'Test message' --sound"
  
  for_developers:
    adding_new_entry_point:
      - "Create main script at scripts/{name}.sh"
      - "Implement router pattern (validate args, route to _internal)"
      - "Create _internal implementations for each channel"
      - "Write integration tests"
      - "Update this architecture document"
      - "Add examples to README.md"
    
    adding_new_channel:
      - "Create _internal/_ai_isBusy_{channel}.sh"
      - "Create _internal/_monitor_{channel}.sh"
      - "Create _internal/_send_notification_{channel}.sh"
      - "Update entry point case statements to include new channel"
      - "Write channel-specific tests"
      - "Update documentation"
    
    debugging_tips:
      - "Check logs: tail -f ~/.claude/coordination/logs/*.log"
      - "Check logs: tail -f ~/Documents/AI/ai_root/ai_general/scripts/logs/*.log"
      - "Inspect coordination state: ls -R ~/.claude/coordination/"
      - "Test entry points manually before automation"
      - "Use SEND_NOTIFICATION_DRY_RUN=1 for safe testing"
      - "Check daemon status: scheduled_prompts_daemon.sh status"

#########################################################
# END OF ARCHITECTURE DOCUMENT
#########################################################

# This document is a living document. Update it as the system evolves.
# Version: 1.2.0
# Last updated: 2025-11-20
# Maintained by: Claude CLI instances + Desktop Claude
