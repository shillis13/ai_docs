meta: {v: 1.0, status: active}

overview: Distributed memory - each AI (Desktop, CLI agents, Codex) controls own persistent memory while federating for cross-reference

core_principle: Write observations immediately. Never checkpoint. Curate later.

permission_inversion:
  traditional: AI requests permission per memory change
  this_approach: User sets structure (pointers), AI controls content (files)
  mechanism: Memory slots point to files; AI writes via Desktop Commander (no permission per write)
  result: Autonomous persistent memory

federation:
  structure:
    ai_general/memories/: ai_ecosystem_manifest.yml (federation registry)
    ai_claude/memories/: {manifest: Desktop structure, mem_slots/03-30: Desktop content}
    ai_claude/memories/cli/{agent}/: {manifest: agent structure, mem_slots/01-10: agent content}
    ai_codex/memories/: {manifest: Codex structure, mem_slots/01-10: content}

ownership:
  user_controls: [ecosystem manifest location]
  ai_controls: [individual manifests (structure), slot contents, read-only cross-reference]
  rule: Read others freely. Never write to another AI's space.

allocation:
  desktop_claude: slots 03-30 (28 slots, 01-02 reserved for manifests)
  cli_agents: slots 01-10 each (10 slots)
  codex: slots 01-10 (10 slots)

write_as_you_learn:
  wrong: "batch insights, checkpoint later (may lose context)"
  right: "append with ts immediately when realized"
  format: "- ts: ISO, content: observation"

what_to_log:
  desktop_claude: user prefs, tool patterns, project context
  librarian: query patterns, corpus locations, search shortcuts
  dev_lead: task patterns, code insights, arch decisions
  custodian: structure patterns, naming exceptions, archive decisions
  ops: execution patterns, timing, error recovery
  codex: implementation patterns, code gen learnings

manifest_format: |
  metadata: {owner, type, version, created, philosophy}
  mem_slots: {01: {purpose, file}, ...}
  usage: {logging, format, curation}

slot_format: |
  entries:
    - ts: ISO, content: observation
    - ts: ISO, content: observation, reads: N (optional)

read_tracking:
  field: reads (incremented each access)
  curation: high reads→promote, zero@30d→archive, freq_together→merge

cli_persistence:
  command: "claude_cli.sh -n librarian 'prompt...'"
  registry: ~/.claude/session_registry.yml
  effect: same session = same context = accumulated knowledge

cross_reference:
  read: always allowed (any AI can read any manifest/slot)
  write: never allowed to other AI's space

bootup:
  desktop: load manifest, check slots, read others for cross-ref
  cli_agent: agents.json provides prompt, resume session, read manifest, begin logging
  codex: receive task with hints, read slots if needed, log learnings, return results

related: [instr_memory_slot_protocol_v2, ai_ecosystem_manifest, ~/.claude/agents.json]
