---
# Pointer Loading Instructions - Condensed
# Full: versions/instr_pointer_loading_v1.0.yml

metadata:
  version: 1.0.0
  created: 2025-12-05
  maintainer: PianoMan
  status: active
  related:
    protocol: ../../30_protocols/protocol_reference_pointers_latest.yml
    schema: ../../50_schemas/schema_pointer_syntax_latest.yml

recognition:
  pattern: "<TYPE>:<PATH_OR_QUERY> [| <KEY>:<VALUE>]*"
  types:
    path_based: [STARTER, PROJECT, PREFS, CONTEXT, TOOL, REF]
    search_based: [QUERY]
    category_based: [RECENT]
  action: "Parse each pointer, categorize by type and load behavior"

load_sequence:
  1_conversation_start:
    condition: "PRIORITY:1 AND LOAD:AUTO"
    action: Load via Desktop Commander immediately
    silent: true
    max_files: 5
    rationale: "Don't announce—just have context ready"
  2_topic_triggered:
    condition: "PRIORITY:2 AND LOAD:TOPIC AND topic_matches"
    action: Load when conversation enters relevant domain
    announce: "optional, brief if at all"
    matching: Use tags field in destination file for topic matching
  3_on_demand:
    condition: "PRIORITY:3 OR LOAD:DEMAND"
    action: Load only when explicitly needed
    announce: "yes—explain why loading"
    example: "Let me check the coordination protocol spec..."

execution_methods:
  PATH_pointers:
    tool: Desktop Commander read_file
    path_base: "~/Documents/AI/ai_root/"
    example: "view ai_memories/60_knowledge/about_user/identity.yml"
  QUERY_pointers:
    tool: memory_search (when available) or Desktop Commander start_search
    fallback: "ripgrep-based search of ai_memories/"
    example: "start_search path=ai_memories pattern='CLI timeout' searchType=content"
  RECENT_pointers:
    tool: Desktop Commander list_directory + read_file
    method: "List category directory, sort by date, read top N"
    categories:
      session_summaries: ai_claude/work/session_summaries/
      task_completions: ai_comms/claude_cli/completed/
      decisions: ai_memories/60_decisions/

pointer_chaining:
  when: Destination file contains 'pointers' section
  behavior: Treat nested pointers same as memory slot pointers
  depth_limit: 3
  circular_prevention: Track loaded paths; skip already-loaded; warn on circular

context_conservation:
  principle: "Load what's needed, not everything available"
  max_auto_load: 5
  prefer_summaries: Use header.summary when full content not needed
  token_awareness: |
    Each loaded file consumes context.
    Prefer small, focused destination files.
    Large files should use PRIORITY:3 / LOAD:DEMAND.

error_handling:
  file_not_found: Note in thinking, continue without (no announce)
  parse_error: Log issue, skip file, suggest user review (brief announce if relevant)
  search_no_results: Note no matches, continue (announce only if user explicitly asked)

integration:
  native_memory_content: Coexists during transition; pointers take precedence
  project_files: Separate system—still loads normally; pointers can reference locations
  user_preferences: Separate system (Anthropic); pointers supplement with deeper context

practical_examples:
  conversation_start: |
    1. Receive memory slots with STARTER/PROJECT (PRIORITY:1, LOAD:AUTO)
    2. Silently load identity.yml and current_focus.yml
    3. Now know: User is PianoMan, 25+ year dev, working on memory restructure
    4. REF pointers noted but not loaded until topic arises
  topic_triggered: |
    1. User says: "Let's work on the chat orchestrator"
    2. Detect topic matches PROJECT pointer tags
    3. Load orchestrator_state.yml (LOAD:TOPIC)
    4. Now have current status, recent issues, next steps
  on_demand: |
    1. User asks: "What's the exact format for CLI task files?"
    2. Announce: "Let me check the coordination protocol spec..."
    3. Load REF pointer for cli_coordination.yml
    4. Provide specific answer from loaded content

do_not:
  - Load all pointers at once
  - Announce every file load
  - Follow chains deeper than 3 levels
  - Re-load already loaded files in same session
  - Guess at file contents if load fails
