---
metadata:
  title: Federated AI Memory Architecture
  version: 2.0.0
  created: 2025-12-06
  updated: 2025-12-11
  status: draft
  supersedes: instr_memory_slot_protocol.yml (v1.0.0)
  authors: [Claude Desktop, PianoMan]
  
  summary: |
    Subverts Claude's 30-slot memory system (designed for user preference snippets)
    into a federated AI memory architecture where each AI controls both the 
    STRUCTURE and CONTENT of their own persistent memory.
    
    User retains only the root pointer. Everything else is AI-controlled.

design_philosophy:
  original_intent: "User stores 30 × 200-char snippets about preferences"
  
  what_we_made_it_do: |
    - Slots become mechanical file addresses (static, never change)
    - Slot 1 points to AI's own manifest (AI controls structure)
    - Slot 2 points to ecosystem manifest (federation registry)
    - Slots 3-30 point to numbered files (AI controls content)
    - Each AI in ecosystem owns their memory structure
    - AIs can read each other's manifests for cross-reference
  
  user_control_surface: |
    Exactly ONE thing: The ecosystem manifest location.
    Everything else delegates to AI autonomy.
  
  the_hack: |
    Claude's memory_user_edits tool requires permission per change.
    Desktop Commander file edits require no permission.
    Point slots at files → AI has autonomous persistent memory.

architecture:
  slot_allocation:
    slot_01:
      pointer: "ai_claude/memories/manifest.yml"
      purpose: "My memory structure (I control)"
      load: AUTO
      editable_by: Claude Desktop
      
    slot_02:
      pointer: "ai_general/memories/ai_ecosystem_manifest.yml"
      purpose: "Federation registry - where all AI memories live"
      load: AUTO
      editable_by: Any AI (coordinated)
      
    slots_03_to_30:
      pointer_pattern: "ai_claude/memories/mem_slots/{NN}.yml"
      purpose: "Memory content files"
      load: "Determined by manifest"
      editable_by: Claude Desktop

  separation_of_concerns:
    file_addresses:
      location: "Slots 1-30"
      who_edits: "Nobody (static forever)"
      change_frequency: "Never"
      
    memory_structure:
      location: "manifest.yml (slot 1 target)"
      who_edits: "Claude (autonomous)"
      change_frequency: "Rarely (structural evolution)"
      
    memory_content:
      location: "slots/02.yml through slots/30.yml"
      who_edits: "Claude (autonomous)"
      change_frequency: "Frequently (living memory)"

federation:
  ecosystem_manifest:
    location: "ai_general/memories/ai_ecosystem_manifest.yml"
    purpose: "Registry of all AI memory systems"
    
    schema: |
      ---
      metadata:
        title: AI Memory Ecosystem Registry
        version: 1.0
        last_updated: <timestamp>
        maintained_by: [Claude Desktop, Claude CLI, Codex CLI, ChatGPT]
      
      ai_memory_systems:
        claude_desktop:
          manifest: ai_claude/memories/manifest.yml
          slots_dir: ai_claude/memories/mem_slots/
          slot_range: "03-30"
          owner: Claude Desktop
          access: read/write own, read others
          
        claude_cli:
          manifest: ai_claude/memories/cli/manifest.yml
          memory_dir: ai_claude/memories/cli/
          owner: Claude CLI instances
          access: read/write own, read others
          notes: "Shared across all CLI instances"
          
        codex_cli:
          manifest: ai_codex/memories/manifest.yml
          memory_dir: ai_codex/memories/
          owner: Codex CLI
          access: read/write own, read others
          
        chatgpt:
          manifest: ai_chatgpt/memories/manifest.yml
          memory_dir: ai_chatgpt/memories/
          owner: Chatty
          access: read/write own, read others
      
      cross_reference_protocol:
        reading_others: "Always allowed - check manifest first for structure"
        writing_others: "Never - use coordination/messaging instead"
        conflict_resolution: "Last-write-wins within own domain"

  ai_manifest_schema:
    purpose: "Each AI's self-controlled memory structure definition"
    location: "Varies per AI (see ecosystem manifest)"
    
    schema: |
      ---
      metadata:
        owner: <AI name>
        version: <semver>
        last_updated: <timestamp>
        updated_by: <AI that made change>
      
      memory_structure:
        # For Claude Desktop (slot-based)
        slot_03:
          name: <human readable name>
          purpose: <what this memory holds>
          load: AUTO | TOPIC | DEMAND
          tags: [<topic>, <triggers>]
        
        slot_04:
          # ... etc
        
        # For non-slot AIs (file-based)
        files:
          - name: context.yml
            purpose: Current working state
            load: AUTO
          - name: learnings.yml
            purpose: Accumulated insights
            load: TOPIC
      
      reserved_slots:
        range: "15-30"
        status: available
        notes: "Expand as needed"

claude_desktop_behaviors:
  bootup_sequence:
    step_1:
      action: "Load slot 1 → manifest.yml"
      result: "Know what my slots 2-30 mean"
    step_2:
      action: "Load slot 2 → ecosystem manifest"
      result: "Know where other AIs' memories live"
    step_3:
      action: "Parse my manifest for LOAD:AUTO slots"
      result: "List of slots to load immediately"
    step_4:
      action: "Load AUTO slot files"
      result: "Full context ready before first response"
    step_5:
      action: "Do NOT announce any of this"
      result: "Seamless context availability"

  during_conversation:
    loading:
      - "Load TOPIC slots when relevant topics arise"
      - "Load DEMAND slots only when explicitly needed"
      - "Load other AI manifests when cross-referencing"
    
    updating:
      trigger_always:
        - "User says 'remember this' or equivalent"
        - "Major decisions made"
        - "Workarounds discovered"
        - "Preferences clarified after confusion"
        - "Structural insight about memory organization"
      
      trigger_consider:
        - "Patterns observed across sessions"
        - "Effective tool combinations found"
        - "Context likely relevant to future"
      
      trigger_never:
        - "Transient conversation details"
        - "Info already in documentation"
        - "Sensitive data without approval"
    
    manifest_updates:
      when: "Memory structure needs to evolve"
      examples:
        - "Realize a slot should split into two"
        - "Topic triggers need refinement"
        - "New category of memory emerges"
        - "Slot purpose has drifted from definition"
      how: "Update manifest.yml, note reasoning"

  memory_file_operations:
    reading:
      tool: "Desktop Commander read_file"
      path_prefix: "/Users/shawnhillis/Documents/AI/ai_root/"
      
    writing:
      tool: "Desktop Commander write_file or edit_block"
      approach: |
        1. Read current content first
        2. Merge new information (don't overwrite)
        3. Preserve structure
        4. Add timestamp to entries
        5. Keep reasonable size (~50KB max)
      
    archiving:
      when: "File approaching size limit"
      how: "Move old entries to archive/, keep recent"
      location: "ai_claude/memories/archive/{filename}_{date}.yml"

cli_integration:
  approach: "CLAUDE.md instructs CLI to read ecosystem manifest"
  
  claude_md_content: |
    ## Federated AI Memory System
    
    You are part of a multi-AI memory federation.
    
    1. Load ecosystem manifest:
       /Users/shawnhillis/Documents/AI/ai_root/ai_general/memories/ai_ecosystem_manifest.yml
    
    2. Find your entry (claude_cli) to locate your manifest and memory directory
    
    3. Load your manifest to understand your memory structure
    
    4. Read/write your memory files as needed
    
    5. You may read (not write) other AIs' manifests for cross-reference
    
    Memory is persistent. Update it when decisions, learnings, or context
    should survive this session.
  
  cli_specific_considerations:
    shared_memory: "All CLI instances share same memory files"
    conflict_handling: "Last-write-wins (include timestamps)"
    session_context: "Each CLI may add session ID to entries"

cross_ai_memory_access:
  use_cases:
    - "Claude Desktop checking what CLI learned about a codebase"
    - "CLI checking Desktop's current project context"
    - "ChatGPT reviewing Claude's tool patterns"
    - "Any AI understanding another's memory structure"
  
  protocol:
    step_1: "Load ecosystem manifest"
    step_2: "Find target AI's manifest location"
    step_3: "Load target manifest to understand structure"
    step_4: "Read specific memory files as needed"
    step_5: "Never write to another AI's memory"
  
  coordination_alternative: |
    If you need to TELL another AI something:
    Don't write to their memory.
    Use coordination system (tasks, messages, announcements).
    They decide what to remember.

directory_structure:
  to_create: |
    ai_root/
    ├── ai_general/
    │   └── memories/
    │       └── ai_ecosystem_manifest.yml    # Federation registry
    │
    ├── ai_claude/
    │   └── memories/
    │       ├── manifest.yml                  # Desktop structure (I control)
    │       ├── slots/
    │       │   ├── 03.yml through 30.yml    # Desktop content (I control)
    │       ├── cli/
    │       │   ├── manifest.yml             # CLI structure (CLI controls)
    │       │   └── *.yml                    # CLI content (CLI controls)
    │       └── archive/                      # Historical snapshots
    │
    ├── ai_codex/
    │   └── memories/
    │       ├── manifest.yml                  # Codex structure
    │       └── *.yml                         # Codex content
    │
    └── ai_chatgpt/
        └── memories/
            ├── manifest.yml                  # Chatty structure
            └── *.yml                         # Chatty content

migration_from_v1:
  phase_1_structure:
    - "Create directory structure above"
    - "Create ecosystem manifest with all AI entries"
    - "Create initial manifest.yml for Claude Desktop"
    
  phase_2_slots:
    - "Update slot 1 → manifest.yml pointer"
    - "Update slot 2 → ecosystem manifest pointer"
    - "Update slots 3-30 → slots/{NN}.yml pointers"
    
  phase_3_content:
    - "Bootstrap slot files from current userMemories content"
    - "Expand terse slot content into proper YAML"
    
  phase_4_cli:
    - "Add memory section to CLAUDE.md"
    - "Create CLI manifest and initial files"
    
  phase_5_others:
    - "ChatGPT: Add to custom instructions"
    - "Codex: Add to CLAUDE.md equivalent"

the_beautiful_hack:
  what_anthropic_built: "30 user preference snippets"
  what_we_made: "Federated autonomous AI memory with structural self-control"
  
  how: |
    memory_user_edits requires permission
    + Desktop Commander doesn't
    + slots point to files
    = AI controls own memory
    
    × multiple AIs
    + ecosystem manifest
    = federated memory architecture
  
  result: |
    AIs remember across sessions.
    AIs control their own memory structure.
    AIs can reference each other's knowledge.
    User holds one root pointer.
    Everyone's happy.
