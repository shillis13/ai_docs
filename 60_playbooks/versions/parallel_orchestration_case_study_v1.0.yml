---
metadata:
  title: Multi-Level Parallel Orchestration Case Study
  version: 1.0.0
  created: 2025-12-10
  maintainer: PianoMan
  status: active
  category: case-study

summary: |
  Documented execution of parallel document condensation across 7 directories
  using 7 simultaneous Claude CLI workers, each orchestrating Codex for validation,
  with Desktop Claude monitoring via AT self-wake pattern.

orchestration_layers:
  level_1_desktop_claude:
    role: Strategic coordinator
    responsibilities:
      - Created task specification (req_1063)
      - Launched 7 parallel CLI workers
      - Set AT self-wake alarms
      - Monitored progress on wake
      - Verified quality of results
    did_not_do:
      - File condensation (delegated)
      - Validation (delegated to Codex)
      - Direct file manipulation

  level_2_claude_cli:
    role: Autonomous execution workers
    agent_used: librarian  # -A librarian flag
    count: 7 parallel instances
    session_names:
      - condense_10_arch
      - condense_20_reg
      - condense_30_proto
      - condense_40_specs
      - condense_50_schemas
      - condense_60_play
      - condense_70_instr
    responsibilities:
      - Read original files in assigned directory
      - Create condensed versions
      - Launch Codex for validation
      - Iterate on gaps (max 3 rounds)
      - Write final condensed files
    launch_pattern: |
      claude_cli.sh -t -a -s {session_name} -A librarian "{prompt}"
      
      Flags:
        -t         : Run in tmux (persistent, detached)
        -a         : Auto-approve operations
        -s NAME    : Named session for monitoring
        -A librarian : Use librarian agent profile

  level_3_codex:
    role: Independent validator
    invoked_by: Claude CLI workers
    purpose: Compare original vs condensed, find gaps
    pattern: |
      codex_cli.sh -t -s val_{name} -a "Compare ORIGINAL vs CONDENSED.
      List operational info missing. Output gaps with severity."

self_wake_pattern:
  mechanism: AT job scheduling future prompt
  implementation: |
    cat << 'EOF' | at now + 5 minutes
    send_prompt.sh claude-desktop "AT wake-up: Check status" --force --submit
    EOF
  
  key_insight: "AT is my wake-up alarm, not CLI's doorbell"
  
  on_wake_actions:
    - Check tmux sessions still alive
    - Count files in condensed/ directories
    - Verify progress vs last check
    - Set another AT if work continues
    - Wrap up and report if complete

execution_timeline:
  "21:36": Launched 7 parallel CLI workers
  "21:38": Set first AT wake (5 min)
  "21:43": Wake #1 - 2 directories complete, progress on others
  "21:48": Wake #2 - 5 directories complete
  "21:52": Wake #3 - 6 complete, 10_arch partial
  "21:57": Wake #4 - All sessions exited, 10_arch incomplete
  "21:58": Launched cleanup worker for 5 missing files
  "22:02": Final verification - ALL COMPLETE

results:
  directories_processed: 7
  files_condensed: ~48
  original_lines: 12,773
  condensed_lines: 3,658
  reduction: 72%
  estimated_tokens_saved: ~71,000
  total_time: ~25 minutes

lessons_learned:
  - Parallel workers dramatically reduce wall-clock time
  - librarian agent appropriate for file-heavy documentation work
  - AT self-wake provides agency without human loop
  - Some workers may exit early or miss files - cleanup pass needed
  - Codex validation catches real gaps (not just rubber-stamping)

prerequisites:
  - claude_cli.sh wrapper with -t, -a, -A flags
  - codex_cli.sh for validation
  - send_prompt.sh with --force flag
  - AT daemon running
  - Defined agent profiles in ~/.claude/agents.json

replication_steps:
  1: Create task spec defining scope per worker
  2: Launch N workers with unique session names
  3: Set AT wake for monitoring interval
  4: On wake - check sessions, count outputs, assess progress
  5: Repeat AT until all sessions exit
  6: Verify completeness, run cleanup if needed
  7: Quality-check sample outputs
