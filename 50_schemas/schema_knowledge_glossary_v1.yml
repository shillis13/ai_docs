# Knowledge Glossary Schema
# Version: 1.0.0
# Purpose: Enable Claude instances to recognize domain terms and know where to find details
# Maintainer: Librarian CLI agent
# Load: AUTO (include in every session's initial context)

metadata:
  title: AI Root Knowledge Glossary
  version: 1.0.0
  schema_version: "schema_knowledge_glossary_v1"
  generated: null  # ISO timestamp when regenerated
  generator: librarian
  term_count: null  # Total terms indexed
  file_count: null  # Files scanned
  
  purpose: |
    Solves the bootstrap problem: Claude needs to know what's IN files 
    to know WHEN to load them. This glossary provides term recognition
    and pointer resolution without loading full documents.
    
  usage: |
    When Claude encounters a term from this glossary in conversation:
    1. Use definition for immediate context
    2. Load primary_ref if details needed
    3. Check also_in for related context
    
  regeneration: |
    Librarian rebuilds on: new file additions, weekly maintenance,
    or on-demand when gaps discovered.

# =============================================================================
# GLOSSARY TERMS
# =============================================================================
# Sorted alphabetically for human readability
# Claude should pattern-match against term and aliases

terms:

  # --- Example Entry (delete after real entries added) ---
  example_term:
    term: "Example Term"
    aliases: [example, sample term]  # Alternative phrasings to match
    domain: meta  # Category: architecture|protocol|tool|concept|workflow
    definition: |
      One to two sentences explaining what this term means in our system.
      Should be self-contained enough to answer "what is X?" without loading files.
    primary_ref: "REF:ai_general/docs/XX_category/filename.yml"
    also_in:
      - "REF:ai_general/docs/other_file.yml"
      - "REF:ai_general/docs/another_file.md"
    related_terms: [other_term, another_concept]  # Cross-references within glossary

# =============================================================================
# DOMAIN CATEGORIES
# =============================================================================
# Used for grouping and filtering terms

domains:
  architecture:
    description: "System design patterns, layer models, structural concepts"
    examples: [federated memory, continuous memory, drain-and-fill]
    
  protocol:
    description: "Communication patterns, coordination rules, handoff procedures"
    examples: [task coordination, pulse system, CLI coordination v4]
    
  tool:
    description: "MCP servers, utilities, external integrations"
    examples: [Desktop Commander, Codex MCP, mem0, Puppeteer]
    
  concept:
    description: "Mental models, principles, named patterns"
    examples: [context conservation, conductor model, bootstrap problem]
    
  workflow:
    description: "Multi-step procedures, operational sequences"
    examples: [overnight automation, peer review, memory migration]
    
  entity:
    description: "Named systems, agents, platforms"
    examples: [Chatty, librarian, custodian, Claude Desktop]

# =============================================================================
# EXTRACTION GUIDANCE FOR LIBRARIAN
# =============================================================================

extraction_rules:
  
  what_to_index:
    - "Named patterns with specific meaning in our system"
    - "Acronyms and abbreviations we use"
    - "Tool names and their purposes"
    - "Protocol names and versions"
    - "Architectural concepts unique to our system"
    - "Named agents/roles (librarian, custodian, etc.)"
    
  what_to_skip:
    - "Generic programming terms (API, JSON, YAML)"
    - "Standard tool names without our-specific usage (Git, Python)"
    - "One-off mentions without recurring significance"
    - "Terms already well-defined in Claude's training"
    
  definition_guidelines:
    - "1-2 sentences maximum"
    - "Answer 'what is X?' without requiring file load"
    - "Include key distinguishing characteristics"
    - "Reference relationships to other terms where helpful"
    
  primary_ref_selection:
    - "Choose the file that DEFINES the term (not just mentions)"
    - "Prefer condensed versions over full versions"
    - "Prefer specs/protocols over playbooks for concepts"
    - "Prefer playbooks over specs for procedures"

# =============================================================================
# MEM0 INTEGRATION
# =============================================================================

mem0_integration:
  
  purpose: |
    While scanning files for glossary terms, librarian should simultaneously
    create/update mem0 memories. Single traversal, dual output.
    
  what_to_memorize:
    - "Key architectural decisions and their rationale"
    - "Tool capabilities and limitations discovered empirically"
    - "User preferences and patterns observed in documentation"
    - "Cross-file relationships not obvious from structure"
    - "Historical context: why things are the way they are"
    
  memory_format:
    template: |
      [DOMAIN] TERM: definition
      Source: file_path
      Context: why this matters / when relevant
      
    example: |
      [PROTOCOL] CLI Coordination v4: Directory-based task lifecycle 
      (to_execute → in_progress → completed) enabling autonomous CLI work.
      Source: protocol_taskCoordination.condensed.yml
      Context: Use when delegating multi-step work to CLI agents.
      
  deduplication:
    - "Check existing mem0 memories before creating"
    - "Update existing memories if new info found"
    - "Tag memories with source file for traceability"
    
  tagging:
    required_tags:
      - source_file: "Path to originating document"
      - domain: "From domains list above"
      - extracted_date: "When librarian processed this"
    optional_tags:
      - related_terms: "Cross-references"
      - confidence: "high|medium if definition inferred"

# =============================================================================
# OUTPUT FILES
# =============================================================================

outputs:
  
  glossary_file:
    path: "ai_general/docs/20_registries/glossary_knowledge_index.yml"
    load_priority: AUTO
    estimated_tokens: "~2000-4000 depending on term count"
    format: "This schema, with terms section populated"
    
  condensed_glossary:
    path: "ai_general/docs/20_registries/glossary_knowledge_index.condensed.yml"
    load_priority: AUTO
    estimated_tokens: "~800-1200"
    format: |
      Minimal format for token conservation:
      terms:
        term_name: "definition | primary_ref"
        another_term: "definition | primary_ref"
    note: "Use when full glossary too heavy; loses also_in and aliases"

# =============================================================================
# MANIFEST ENHANCEMENT SPEC
# =============================================================================
# Additions to _knowledge_manifest.yml for trigger-based loading

manifest_enhancements:

  per_file_additions:
    triggers:
      description: "3-5 phrases that should prompt loading this file"
      format: "triggers: [phrase one, phrase two, concept name]"
      guidance: |
        Choose phrases a user would naturally say when they need this file.
        Include both formal term and casual phrasing.
        Example: [CLI delegation, assign to CLI, overnight work, async tasks]
        
    abstract:
      description: "1-2 sentence summary of what this file provides"
      format: "abstract: 'Summary text here'"
      guidance: |
        Answer: "What question does this file answer?"
        Should help Claude decide if full file needed.
        Example: "Defines the directory-based task lifecycle for CLI agents 
                  including file formats, state transitions, and error handling."
        
    answers:
      description: "Questions this file directly answers"
      format: "answers: ['How do I...?', 'What is...?']"
      guidance: |
        Phrase as questions a user would ask.
        Example: ['How do CLI agents pick up tasks?', 
                  'What happens if a task fails?']

  example_enhanced_entry:
    pointer: "REF:ai_general/docs/30_protocols/protocol_taskCoordination.condensed.yml"
    tokens: ~2969
    triggers: [CLI coordination, task delegation, async work, overnight automation, task lifecycle]
    abstract: |
      Defines v4 CLI coordination protocol: directory-based task management,
      file formats for task specs, state transitions, and multi-agent coordination.
    answers:
      - "How do I delegate work to CLI agents?"
      - "What's the task file format?"
      - "How do tasks move through the lifecycle?"
